{-# LANGUAGE NamedFieldPuns #-}

-- | Implements steps 1 to 16 of <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.  Registering a New Credential">
module Crypto.Fido2.Attestation
  ( verifyAttestationResponse,
    Error (..),
    AttestationResult (..),
  )
where

import Codec.CBOR.Term (Term)
import Control.Monad (when)
import Crypto.Fido2.Protocol
  ( AttestationObject (AttestationObject, attStmt, authData, fmt),
    AttestedCredentialData,
    AuthenticatorAttestationResponse (AuthenticatorAttestationResponse, attestationObject, clientData),
    AuthenticatorData (AuthenticatorData, attestedCredentialData, rpIdHash, userPresent, userVerified),
    ClientData (ClientData, challenge, clientDataHash, origin, typ),
    URLEncodedBase64 (),
    WebauthnType (Create),
  )
import qualified Crypto.Hash as Hash
import Crypto.Hash (Digest, SHA256)
import Data.Text (Text)
import qualified Data.Text.Encoding as Text

data Error
  = InvalidWebauthnType
  | ChallengeDidNotMatch
  | OriginDidNotMatch
  | RpIdMismatch
  | UserNotPresent
  | UserNotVerified
  | UnsupportedAttestationFormat
  | InvalidAttestationStatement
  | NoAttestedCredentialDataFound

-- | Use this result to implement step 17, 18 and 19 of
-- <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.
-- Registering a New Credential">
--
-- 17 Check that the 'credentialId' is not yet registered to any other user.
-- If registration is requested for a credential that is already registered to
-- a different user, the Relying Party SHOULD fail this registration ceremony,
-- or it MAY decide to accept the registration, e.g. while deleting the older
-- registration.
--
-- 18 If the attestation statement 'attStmt' verified successfully and is
-- found to be trustworthy, then register the new credential with the account
-- that was denoted in the options.user passed to create(), by associating it
-- with the 'credentialId' and 'credentialPublicKey' in the
-- 'attestedCredentialData' in 'authData', as appropriate for the Relying
-- Party's system.
--
--
-- 19 If the attestation statement attStmt successfully verified but is not
-- trustworthy per step 16 above, the Relying Party SHOULD fail the
-- registration ceremony.
--
-- NOTE: However, if permitted by policy, the Relying Party MAY register the
-- credential ID and credential public key but treat the credential as one with
-- self attestation (see §6.4.3 Attestation Types). If doing so, the Relying
-- Party is asserting there is no cryptographic proof that the public key
-- credential has been generated by a particular authenticator model.
--
-- Verification of attestation objects requires that the Relying Party has a
-- trusted method of determining acceptable trust anchors in step 15 above.
-- Also, if certificates are being used, the Relying Party MUST have access to
-- certificate status information for the intermediate CA certificates. The
-- Relying Party MUST also be able to build the attestation certificate chain
-- if the client did not provide this chain in the attestation information.
data AttestationResult = Trustworthy AttestedCredentialData | NotTrustworthy

-- | Runs step 1 to 16 of
-- <https://www.w3.org/TR/webauthn/#registering-a-new-credential "7.1.  Registering a New Credential">
--
-- Steps 17, 18 and 19 should be taken care of by the caller of the API. The
-- function returns all the information needed for these steps.
verifyAttestationResponse ::
  Text ->
  Text ->
  URLEncodedBase64 ->
  Bool -> -- TODO: boolean blindness
  AuthenticatorAttestationResponse ->
  Either Error AttestationResult
verifyAttestationResponse
  origin
  rpId
  challenge
  userVerificationRequired
  AuthenticatorAttestationResponse {clientData, attestationObject} = do
    -- 1. Let JSONtext be the result of running UTF-8 decode on the value of
    -- response.clientDataJSON.
    --
    -- --> This is implied in the decoder of 'AuthenticatorAttestationResponse'
    --
    --
    -- 2. Let C, the client data claimed as collected during the credential
    -- creation, be the result of running an implementation-specific JSON parser on
    -- JSONtext.
    --
    -- --> This is implied in the decoder of 'AuthenticatorAttestationResponse'
    --
    -- 3. Verify that the value of C.type is webauthn.create.
    let ClientData {typ} = clientData
    when (typ /= Create) $ Left InvalidWebauthnType
    -- 4. Verify that the value of C.challenge matches the challenge that was
    -- sent to the authenticator in the create() call.
    let ClientData {challenge = challenge'} = clientData
    when (challenge /= challenge') $ Left ChallengeDidNotMatch
    -- 5. Verify that the value of C.origin matches the Relying Party's origin.
    let ClientData {origin = origin'} = clientData
    when (origin /= origin') $ Left OriginDidNotMatch
    -- 6. Verify that the value of C.tokenBinding.status matches the state of
    -- Token Binding for the TLS connection over which the assertion was
    -- obtained. If Token Binding was used on that TLS connection, also verify
    -- that C.tokenBinding.id matches the base64url encoding of the Token Binding
    -- ID for the connection.
    --
    -- --> TODO(arianvp): TokenBinding is not yet supported. Ignore

    -- 7. Compute the hash of response.clientDataJSON using SHA-256.
    -- --> Already available as 'clientDataHash'
    let ClientData {clientDataHash} = clientData
    -- 8. Perform CBOR decoding on the attestationObject field of the
    -- AuthenticatorAttestationResponse structure to obtain the attestation
    -- statement format fmt, the authenticator data authData, and the attestation
    -- statement attStmt.
    let AttestationObject {fmt, authData, attStmt} = attestationObject
    -- 9. Verify that the rpIdHash in authData is the SHA-256 hash of the RP ID
    -- expected by the Relying Party.
    let AuthenticatorData {rpIdHash} = authData
    when (Hash.hash (Text.encodeUtf8 rpId) /= rpIdHash) $ Left RpIdMismatch
    -- 10. Verify that the User Present bit of the flags in authData is set.
    let AuthenticatorData {userPresent} = authData
    when (not userPresent) $ Left UserNotPresent
    -- 11. If user verification is required for this registration, verify that
    -- the User Verified bit of the flags in authData is set.
    let AuthenticatorData {userVerified} = authData
    when (userVerificationRequired && (not userVerified)) $ Left UserNotVerified
    -- 12. Verify that the values of the client extension outputs in
    -- clientExtensionResults and the authenticator extension outputs in the
    -- extensions in authData are as expected, considering the client extension
    -- input values that were given as the extensions option in the create()
    -- call. In particular, any extension identifier values in the
    -- clientExtensionResults and the extensions in authData MUST be also be
    -- present as extension identifier values in the extensions member of
    -- options, i.e., no extensions are present that were not requested. In the
    -- general case, the meaning of "are as expected" is specific to the
    -- Relying Party and which extensions are in use.
    -- --> TODO: We do not implement any client extensions currently

    -- 13. Determine the attestation statement format by performing a USASCII
    -- case-sensitive match on fmt against the set of supported WebAuthn
    -- Attestation Statement Format Identifier values. An up-to-date list of
    -- registered WebAuthn Attestation Statement Format Identifier values is
    -- maintained in the IANA registry of the same name [WebAuthn-Registries].
    -- NOTE: We currently only support the '"none"' attestation format
    -- 14. Verify that attStmt is a correct attestation statement, conveying a valid
    -- attestation signature, by using the attestation statement format fmt’s
    -- verification procedure given attStmt, authData and the hash of the
    -- serialized client data computed in step 7.

    -- 15. If validation is successful, obtain a list of acceptable trust
    -- anchors (attestation root certificates or ECDAA-Issuer public keys) for
    -- that attestation type and attestation statement format fmt, from a
    -- trusted source or from policy. For example, the FIDO Metadata Service
    -- [FIDOMetadataService] provides one way to obtain such information, using
    -- the aaguid in the attestedCredentialData in authData.

    -- 16. Assess the attestation trustworthiness using the outputs of the
    -- verification procedure in step 14, as follows:
    -- If self attestation was used, check if self attestation is acceptable
    -- under Relying Party policy.
    -- If ECDAA was used, verify that the identifier of the ECDAA-Issuer
    -- public key used is included in the set of acceptable trust anchors
    -- obtained in step 15.
    -- Otherwise, use the X.509 certificates returned by the verification
    -- procedure to verify that the attestation public key correctly chains up
    -- to an acceptable root certificate.
    -- --> TODO: This is a no-op as we only support "none"
    validateAttStmt fmt attStmt authData clientDataHash

validateAttStmt :: Text -> [(Term, Term)] -> AuthenticatorData -> Digest SHA256 -> Either Error AttestationResult
validateAttStmt "none" [] AuthenticatorData {attestedCredentialData} _ =
  case attestedCredentialData of
    Just attestedCredentialData -> pure $ Trustworthy attestedCredentialData
    Nothing -> Left NoAttestedCredentialDataFound
validateAttStmt "none" _ _ _ = Left InvalidAttestationStatement
validateAttStmt _ _ _ _ = Left UnsupportedAttestationFormat
